---
title: "Tightrope: Normalization of ChIP-seq experiments involving global variations of chromatin marks"
author: '[Benjamin Leblanc](benjaminolivierleblanc@gmail.com)'
date: "`r format(Sys.time(), '%d.%m.%Y')`"
output:
  pdf_document:
    toc: true
    number_sections: true
  html_document:
    toc: true
    number_sections: true
bibliography: biblio/Bibliography.bib
csl: biblio/styles/cell.csl
link-citations: yes
---

```{r config_dependencies, include=FALSE}
library(GenomicAlignments) # scanBamFlag function
```

```{r global_config, include=FALSE}
CFG <- list(
  build = list(
    Biblio = F, # produce the list of bibliographic references
    TxDb   = F, # produce R objects with Ensembl gene annotations
    
    MappedReads      = F, # produce R objects with mapped reads
    BigWigs.RAW      = F, # produce raw bigwig files
    SequencingYields = F, # produce R objects with sequencing yields
    
    ReadCounts    = F, # produce R objects with read count matrixes
    Normalize.RPM = F, # produce R objects with normalized read counts (RPM)
    Normalize.BRD = F, # produce R objects with normalized read counts (BRD)
    BigWigs.RPM   = F, # produce normalized bigwig files (RPM)
    BigWigs.BRD   = F, # produce normalized bigwig files (BRD)
    
    Distributions.RAW = F, # produce images with raw count distributions
    Distributions.RPM = F, # produce images with count distributions (RPM)
    Distributions.BRD = F, # produce images with count distributions (BRD)

    Enrichments.RAW = F, # produce images with raw enrichment distributions
    Enrichments.RPM = F, # produce images with enrichment distributions (RPM)
    Enrichments.BRD = F, # produce images with enrichment distributions (BRD)

    GlobalCorrelations  = F, # produce R objects with whole genome correlations 
    Reproducibility.RAW = F, # produce reproducibility scatter plots (RAW)
    Reproducibility.RPM = F, # produce reproducibility scatter plots (RPM)
    Reproducibility.BRD = F, # produce reproducibility scatter plots (BRD)
    
    ChIP_x_Input.RPM = F, # produce ChIP versus Input scatter plots (RPM)
    ChIP_x_Input.BRD = F, # produce ChIP versus Input scatter plots (BRD)

    SeqPlots.bedfiles = F, # produce bedfiles for seqplots (GNU, TSS, TTS)
    SeqPlots.RPM      = F, # produce R objects with seqplots results (RPM)
    SeqPlots.BRD      = F, # produce R objects with seqplots results (BRD)
    
    update            = F  # produce all (R objects, images)
  ),
  paths = list(
    libraries = "../../libraries",
    UCSC      = "../../data/UCSC",
    Ensembl   = "../../data/Ensembl",
    images    = "images",
    data      = "data",
    results   = "results",
    biblio    = "biblio",
    raw_reads    = "",
    mapped_reads = "",
    bigwigs      = "",
  ),
  files = list(
    blacklist = "../../data/blacklists/ENCODE/Consensus_hg19.bed.gz",
    metadata  = ""
  ),
  organism = list(
    name    = "Homo sapiens",
    taxid   = 9606,
    UCSC    = list(genome = "hg38"),
    Ensembl = list(release = 91),
    BSg_pkg = "BSgenome.Hsapiens.UCSC.hg38",
    TxDb = list(
      source = "Ensembl GRCh38.p10 release 91 (December 2017)",
      portal = "http://Dec2017.archive.ensembl.org/Homo_sapiens",
      gtf = paste0(
        "ftp://ftp.ensembl.org/pub/",
        "release-91/gtf/homo_sapiens/Homo_sapiens.GRCh38.91.gtf.gz"
      )
    ),
    BioMart = list(
      host     = "www.ensembl.org", # Dec2017.archive.ensembl.org
      database = "ensembl",
      dataset  = "hsapiens_gene_ensembl"
    )
  ),
  plots = list(
    ROIs     = c("TSS", "TTS" , "WGT"),
    lst.distributions = c(
      "H3K36me3_untreated_35", "H3K36me3_BIX_35",
      "LEDGF_untreated_35", "LEDGF_BIX_35",
      "Input_untreated_35", "Input_BIX_35",
      "H3K36me3_untreated_25", "H3K36me3_BIX_25",
      "LEDGF_untreated_25", "LEDGF_BIX_25",
      "Input_untreated_25", "Input_BIX_25"
    )
  ),
  args = list(
    correlation.roi = "WGT",
    dna.fragments   = list(breaks = seq(0, 1000, 10)),
    tiling = list(
      space = 1000, # spacing between genomic bins (bp)
      width = 4000  # size of genomic bins (bp)
    ),
    bamflag = list(
      paired = scanBamFlag(
        isDuplicate = F, isUnmappedQuery = F, isProperPair = T
      )
    ),
    BRD = list(
      Combined = list(
        roi = "INTERGENIC", ncl = 1, bdt = c(0.2, 0.02),
        chip = c(
          "H3K36me3_untreated_35", "H3K36me3_BIX_35",
          "LEDGF_untreated_35", "LEDGF_BIX_35"
        ),
        ctrl = c("Input_untreated_35", "Input_BIX_35")
      ),
      H3K36me3 = list(
        roi = "INTERGENIC", ncl = 1, bdt = c(0.2, 0.02),
        chip = c("H3K36me3_untreated_35", "H3K36me3_BIX_35"),
        ctrl = c("Input_untreated_35", "Input_BIX_35")
      ),
      LEDGF = list(
        roi = "INTERGENIC", ncl = 1, bdt = c(0.2, 0.02),
        chip = c("LEDGF_untreated_35", "LEDGF_BIX_35"),
        ctrl = c("Input_untreated_35", "Input_BIX_35")
      )
    )
  )
)
```

```{r global_dependencies, include=FALSE}
# =============================================================================.
# Static package requirements
# -----------------------------------------------------------------------------.

# CRAN ------------------------------------------------------------------------.
library(knitr)
library(tidyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(ggthemes)

# Bioconductor ----------------------------------------------------------------.
library(BSgenome)
library(seqplots)
library(Gviz)
# library(TxDb.Hsapiens.UCSC.hg38.knownGene)

# Github ----------------------------------------------------------------------.

# Homemade --------------------------------------------------------------------.
library(Tightrope)

# =============================================================================.
# Dynamic package requirements (Bioconductor)
# -----------------------------------------------------------------------------.
pkg <- installed.packages()[, "Package"]
lst <- setdiff(CFG$organism$BSg_pkg, pkg)
if(length(lst) > 0) {
  source("https://bioconductor.org/biocLite.R")
  biocLite(lst)
}
library(CFG$organism$BSg_pkg, character.only = T)

# =============================================================================.
# Required source files
# -----------------------------------------------------------------------------.
source(paste0(CFG$paths$libraries, "/benjamin/System.R"))
source(paste0(CFG$paths$libraries, "/benjamin/CommonFunctions.R"))
source(paste0(CFG$paths$libraries, "/benjamin/RData.R"))
source(paste0(CFG$paths$libraries, "/benjamin/GenomicRanges.R"))
source(paste0(CFG$paths$libraries, "/benjamin/SequenceReads.R"))
source("http://www.math.mcmaster.ca/bolker/R/misc/legendx.R")
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(lst, pkg))
```

```{r global_preparations, include=FALSE}
# =============================================================================.
# Check if full update is required depending on the combination of build flags
# -----------------------------------------------------------------------------.
CFG$build$update <- with(CFG$build, update) 
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
for(fpath in CFG$paths) mkdir(fpath)
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(fpath))
```

```{r specific_functions, include=FALSE}
# =============================================================================.
# Compute the genomic length covered by sequencing reads
# -----------------------------------------------------------------------------.
CoveredLength <- function(cvg) {
  s <- 0L
  for(chr in names(cvg)) {
    i <- which(runValue(cvg[[chr]]) > 0)
    s <- s + sum(as.numeric(runLength(cvg[[chr]])[i]))
  }
  s
}
# =============================================================================.
# Compute correlation matrixes
# -----------------------------------------------------------------------------.
CorrelationMatrix <- function(x) {
  m <- matrix(0, ncol(x), ncol(x))
  if(! is.null(colnames(x))) {
    m <- matrix(0, ncol(x), ncol(x), dimnames = list(colnames(x), colnames(x)))
  }
  for(i in 1:ncol(x)) {
    for(j in 1:ncol(x)) {
      m[i, j] <- cor(x[, i], x[, j])
    }
  }
  m
}
# =============================================================================.
# Plot correlation heatmaps
# -----------------------------------------------------------------------------.
PlotCorrelationHeatmap <- function(x, clr.prm, legend = F, ...) {
  colors <- makeColors(seq(-1, 1, length.out = 101), parameters = clr.prm)
  h <- heatmap(x, symm = T, col = colors, zlim = c(-1, 1), ...)
  if(legend) {
    colorLegend(
      "br", horiz = T, size = c(30, 2.5), margin = rep(0, 4),
      parameters = clr.prm, resolution = 101,
      ticks = seq(-1, 1, length.out = 5), tick.pos = -1, cex = 0.8
    )
  }
}
# =============================================================================.
# Plot count distributions
# -----------------------------------------------------------------------------.
PlotCountDistributions <- function(x, path, ...) {
  clr_map    <- function(k) colorize(k , mode = "01", col = "ry")
  jit  <- "unif"
  smx  <- 9
  nxp <- ncol(x)
  png(
    MakePath(CFG$paths$images, path, ext = ".png"),
    width = 1 + 3/9 * nxp, height = 5.5, units = "in", res = 300
  )
  par(mar = c(10, 4, 3, 1), cex.main = 0.9, cex.lab = 0.8, cex.axis = 0.8)
  h <- ParallelHist2D(
    x, nx = 50 * nxp, ny = 100,
    plot = T, clrmap = clr_map, jitter = jit, smoothx = smx,
    las = 2, ...
  )
  dev.off()
}
# =============================================================================.
# Plot count distributions
# -----------------------------------------------------------------------------.
PlotCountDistributionsNoLabels <- function(x, path, ...) {
  clr_map    <- function(k) colorize(k , mode = "01", col = "ry")
  jit  <- "unif"
  smx  <- 9
  nxp <- ncol(x)
  png(
    MakePath(CFG$paths$images, path, ext = ".png"),
    width = 1 + 3/9 * nxp, height = 3, units = "in", res = 300
  )
  par(mar = c(1, 4, 3, 1), cex.main = 0.9, cex.lab = 0.8, cex.axis = 0.8)
  h <- ParallelHist2D(
    x, nx = 50 * nxp, ny = 100,
    plot = T, clrmap = clr_map, jitter = jit, smoothx = smx,
    x.labels = F, ...
  )
  dev.off()
}
# =============================================================================.
# Reproducibility scatterplots
# -----------------------------------------------------------------------------.
PlotReproducibility <- function(cnt, gcm, r1, r2, path, xylim, r = T, ...) {
  clr_map <- function(k) colorize(k , mode = "rank", col = "Bc")
  png(
    MakePath(CFG$paths$images, path, ext = ".png"),
    width = 4.5, height = 4.5, units = "in", res = 300
  )
  par(mar = c(5, 5, 1, 1))
  h <- Histogram2D(
    cnt, plot = T, nx = 200, xlim = xylim, ylim = xylim, clrmap = clr_map,
    xlab = r1, ylab = r2, ...
  )
  abline(a = 0, b = 1, col = grey(0.5), lwd = 2)
  if(r) {
    legend("topleft", legend = paste("r =", round(gcm[r1, r2], 2)), bty = 'n')
  }
  dev.off()
}
# =============================================================================.
# https://stackoverflow.com/questions/3932038/plot-a-legend-outside-of-the-plotting-area-in-base-graphics
# -----------------------------------------------------------------------------.
OverlayLegend <- function(...) {
  op <- par(
    fig=c(0, 1, 0, 1), oma=c(0, 0, 0, 0), mar=c(0, 0, 0, 0), new=TRUE
  )
  on.exit(par(op))
  plot(0, 0, type = 'n', bty = 'n', xaxt = 'n', yaxt = 'n')
  legend(...)
}
```

```{r ucsc_liftover_chains, include=FALSE}
# TODO: Use an environment to globally store seqinfo and chains
# =============================================================================.
# Build chromosome informations and liftOver chains from UCSC
# -----------------------------------------------------------------------------.
if(with(CFG, build$update | ! LoadObj(hg19.seqinfo, path = paths$UCSC))) {
  hg19.seqinfo <- BuildSeqInfo("hg19")
  SaveObj(hg19.seqinfo, path =  CFG$paths$UCSC)
}
# -----------------------------------------------------------------------------.
if(with(CFG, build$update | ! LoadObj(hg19ToHg38, path = paths$UCSC))) {
  hg19ToHg38 <- ImportLiftOverChain(
    paste0(
    "http://hgdownload.cse.ucsc.edu/goldenPath/",
    "hg19/liftOver/hg19ToHg38.over.chain.gz"
    )
  )
  SaveObj(hg19ToHg38, path = CFG$paths$UCSC)
}
```

```{r txdb_source, include=FALSE}
cat(with(CFG$organism$TxDb, MarkdownLink(portal, source)))
```

```{r build_txdb, include=FALSE}
# =============================================================================.
# Build genes from Ensembl/BioMart
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | TxDb | ! LoadObj(EGA91, CFG$paths$Ensembl))) {
  EGA91 <- BuildGeneFeatures(CFG$organism)
  SaveObj(EGA91, path = CFG$paths$Ensembl)
}
if(! exists(paste0("EGA", CFG$organism$Ensembl$release))) stop("check EGA obj.")
# -----------------------------------------------------------------------------.
# Open BioMart connexion
# EGA91$biomart <- with(
#     EGA91$organism$BioMart, useMart(
#     host = host, biomart = database, dataset = dataset
#   )
# )
```

```{r import_blacklist, include=FALSE}
# TODO: Save curated versions of the blacklisted regions as RData
# =============================================================================.
# Import ENCODE blacklisted regions | blacklist <- import(CFG$files$blacklist)
# -----------------------------------------------------------------------------.
blacklist <- read.delim(
  CFG$files$blacklist, header = F, stringsAsFactors = F,
  col.names = c("seqnames", "start", "end", "biotype", "V1", "V2")
)
blacklist <- as(blacklist[, 1:4], "GRanges")
# -----------------------------------------------------------------------------.
# Cleanup and genomic coordinates conversion from hg19 to hg38
blacklist <- with(EGA91, CleanupGRanges(blacklist, hg19.seqinfo, organism$name))
blacklist <- unlist(liftOver(blacklist, hg19ToHg38))
blacklist <- with(EGA91, CleanupGRanges(blacklist, seqinfo, organism$name))
```

```{r build_wgt, include=FALSE}
# =============================================================================.
# Build whole genome tiling bins (avoiding blacklisted regions)
# -----------------------------------------------------------------------------.
chk <- LoadObj(WGT, path = CFG$paths$data, pos = EGA91)
if(with(CFG$build, update | ! chk)) {
  WGT <- with(CFG$args$tiling, GenomicTiling(EGA91$seqinfo, space, width))
  WGT <- CleanupGRanges(WGT, EGA91$seqinfo, EGA91$organism$name, blacklist)
  SaveObj(WGT, path = CFG$paths$data)
  EGA91$WGT <- WGT
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(chk, WGT))
```

```{r build_bedfiles, include=FALSE}
# =============================================================================.
# Export ROIs as bed files
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | SeqPlots.bedfiles)) {
  
  GNU <- CleanupGRanges(
    EGA91$GNU, EGA91$seqinfo, EGA91$organism$name, blacklist, keep.strand = T
  )
  export.bed(GNU, MakePath(CFG$paths$data, "EGA91_GNU.bed"))
  
  TSS <- trim(resize(EGA91$TSS, width = CFG$args$tiling$width, use.names = F))
  TSS <- CleanupGRanges(TSS, EGA91$seqinfo, EGA91$organism$name, blacklist, T)
  export.bed(TSS, MakePath(CFG$paths$data, "EGA91_TSS.bed"))
  
  TTS <- trim(resize(EGA91$TTS, width = CFG$args$tiling$width, use.names = F))
  TTS <- CleanupGRanges(TTS, EGA91$seqinfo, EGA91$organism$name, blacklist, T)
  export.bed(TTS, MakePath(CFG$paths$data, "EGA91_TTS.bed"))
  
  export.bed(EGA91$INTERGENIC, MakePath(CFG$paths$data, "EGA91_INTERGENIC.bed"))
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(GNU, TSS, TTS))
```

```{r import_chipseq_mia, include=FALSE}
# TODO: manage sequencing runs and paired end files (see SRA and ChIP Atlas)
# =============================================================================.
# Load metadata for Mia's ChIP-seq October 2017
# -----------------------------------------------------------------------------.
Mia.meta <- fread(CFG$files$metadata, key = "sample_id", stringsAsFactors = F)
# -----------------------------------------------------------------------------.
Mia.files <- data.table(
  name   = Mia.meta$sample_id,
  paired = T,
  fastq  = fmap(MakePath, CFG$paths$raw_reads, Mia.meta$name),
  bam    = fmap(MakePath, CFG$paths$mapped_reads, Mia.meta$bam_file),
  bai    = "",
  rdata  = fmap(
    MakePath, 
    CFG$paths$mapped_reads, "rdata", Mia.meta$sample_id, ext = ".rdata"
  ),
  key = "name", stringsAsFactors = F
)
Mia.files$bai <- gsub("\\.bam", ".bai", Mia.files$bam)
# =============================================================================.
# Create paths for GAlignments objects
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$mapped_reads, "rdata"))
# =============================================================================.
# Import mapped reads for Mia's ChIP-seq October 2017
# -----------------------------------------------------------------------------.
if(HostName() == "bl_imac") { # mapped reads are available on my work iMac only
  if(! all(file.exists(Mia.files$fastq))) stop("missing ChIP-seq fastq files")
  if(! all(file.exists(Mia.files$bam))) stop("missing ChIP-seq bam files")
  if(! all(file.exists(Mia.files$bai))) stop("missing ChIP-seq bai files")
  chk <- bam2rdata(
    Mia.files$bam, overwrite = with(CFG$build, update | MappedReads),
    path = MakePath(CFG$paths$mapped_reads, "rdata"), names = Mia.files$name,
    paired = T, param = ScanBamParam(flag = CFG$args$bamflag$paired)
  )
  if(! all(file.exists(Mia.files$rdata))) stop("missing ChIP-seq rdata files")
}
# =============================================================================.
# Create paths for results and images
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$results, "RAW"))
mkdir(MakePath(CFG$paths$images,  "RAW"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(chk))
```

```{r bigwigs_raw, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$bigwigs, "RAW"))
Mia.files$bw_raw <- fmap(
  MakePath, CFG$paths$bigwigs, "RAW", Mia.files$name, ext = ".bw"
)
# =============================================================================.
# Generate raw bigwigs
# -----------------------------------------------------------------------------.
if(HostName() == "bl_imac") { # bigwigs are available on my work iMac only
  if(with(CFG$build, update | BigWigs.RAW)) {
    for(lbl in Mia.files$name) {
        message(clock(), " ", lbl , " | loading mapped reads...")
        aln <- readRDS(Mia.files[lbl]$rdata)
        message(clock(), " ", lbl , " | computing coverage...")
        cvg <- coverage(as(aln, "GRanges"))
        message(clock(), " ", lbl , " | saving as bigwig...")
        export.bw(cvg, Mia.files[lbl]$bw_raw)
    }
  }
  if(! all(file.exists(Mia.files$bw_raw))) stop("missing raw bigwig files")
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(lbl, aln, cvg))
gc() # Garbage collector
```

```{r sequencing_yields, include=FALSE}
# =============================================================================.
# Compute sequencing yields
# -----------------------------------------------------------------------------.
chk <- F
chk <- chk | LoadObj(YIELDS, CFG$paths$results)
chk <- chk | LoadObj(DNAFRAGMENTS, CFG$paths$results)
if(with(CFG$build, update | SequencingYields | ! chk)) {
  YIELDS       <- c()
  DNAFRAGMENTS <- c()
  brk <- CFG$args$dna.fragments$breaks
  for(lbl in Mia.files$name) {
    message(clock(), " ", lbl , " | counting fastq and mapped reads...")
    cmd <- paste0('gunzip -c "', Mia.files[lbl]$fastq, '" | wc -l')
    faq <- system(cmd, intern = T)
    faq <- as.numeric(faq) / 4
    bam <- idxstatsBam(Mia.files[lbl]$bam)
    bam <- colSums(bam[, -1])
    if(Mia.files[lbl]$paired) bam[2] <- bam[2] / 2
    message(clock(), " ", lbl , " | loading mapped reads...")
    aln <- as(readRDS(Mia.files[lbl]$rdata), "GRanges")
    message(clock(), " ", lbl , " | calculating covered length...")
    cvg <- CoveredLength(coverage(aln))
    YIELDS <- rbind(
      YIELDS, c(bam[1], fastq = faq, bam[2], rdata = length(aln), covered = cvg)
    )
    message(clock(), " ", lbl , " | making read/fragment size distribution...")
    dfs <- hist(width(aln), breaks = brk, plot = F)$counts
    DNAFRAGMENTS <- rbind(DNAFRAGMENTS, dfs, deparse.level = 0)
  }
  rownames(DNAFRAGMENTS) <- Mia.files$name
  rownames(YIELDS) <- Mia.files$name
  YIELDS <- data.frame(YIELDS)
  SaveObj(DNAFRAGMENTS, CFG$paths$results)
  SaveObj(YIELDS, CFG$paths$results)
}
# -----------------------------------------------------------------------------.
lst <- CFG$plots$lst.distributions
if(! all(rowSums(DNAFRAGMENTS[lst, ]) / YIELDS[lst, "rdata"] == 1)) {
  stop("inconsistency between yields and dna fragments")
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(chk, brk, cmd, faq, bam, aln, dfs, lst))
gc() # Garbage collector
```

```{r read_counts, include=FALSE}
# =============================================================================.
# Compute read count matrixes
# -----------------------------------------------------------------------------.
COUNTS <- new.env(parent = globalenv(), size = NA)
# -----------------------------------------------------------------------------.
chk <- LoadObj(RAW, path = MakePath(CFG$paths$results, "RAW"), pos = COUNTS)
if(with(CFG$build, update | ReadCounts | ! chk)) {
  
  aln.lst <- Mia.files$rdata
  
  RAW <- list()
  
  # Gene units
  message(clock(), " counting reads in gene units...")
  RAW$GNU <- MakeReadCounts(
    aln.lst, EGA91$GNU, Mia.meta$sample_id, ignore.strand = T
  )
  
  # Windows centered on TSS
  message(clock(), " counting reads in TSS...")
  TSS <- resize(EGA91$TSS, width = CFG$args$tiling$width, use.names = F)
  RAW$TSS <- MakeReadCounts(
    aln.lst, TSS, Mia.meta$sample_id, ignore.strand = T
  )
  
  # Windows centered on TTS
  message(clock(), " counting reads in TTS...")
  TTS <- resize(EGA91$TTS, width = CFG$args$tiling$width, use.names = F)
  RAW$TTS <- MakeReadCounts(
    aln.lst, TTS, Mia.meta$sample_id, ignore.strand = T
  )
  
  # Whole genome tiling bins
  message(clock(), " counting reads in whole genome tiling bins...")
  RAW$WGT <- MakeReadCounts(
    aln.lst, EGA91$WGT, Mia.meta$sample_id, ignore.strand = T
  )

  # Intergenic regions
  message(clock(), " counting reads in intergenic regions...")
  RAW$INTERGENIC <- MakeReadCounts(
    aln.lst, EGA91$INTERGENIC, Mia.meta$sample_id, ignore.strand = T
  )
  
  SaveObj(RAW, path = MakePath(CFG$paths$results, "RAW"))
  COUNTS$RAW <- RAW
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(chk, aln.lst, TSS, TTS, RAW))
gc() # Garbage collector
```

```{r normalization_rpm, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$results, "RPM"))
mkdir(MakePath(CFG$paths$images,  "RPM"))
# =============================================================================.
# Compute and apply scaling factors (RPM method)
# -----------------------------------------------------------------------------.
YIELDS$rpm_mean  <- mean(YIELDS$rdata)
YIELDS$rpm_coeff <- YIELDS$rpm_mean / YIELDS$rdata
# -----------------------------------------------------------------------------.
chk <- LoadObj(RPM, path = MakePath(CFG$paths$results, "RPM"), pos = COUNTS)
if(with(CFG$build, update | Normalize.RPM | ! chk)) {
  RPM <- COUNTS$RAW
  for(roi in names(RPM)) {
    lbl <- colnames(RPM[[roi]])
    RPM[[roi]] <- t(t(RPM[[roi]]) * YIELDS[lbl, ]$rpm_coeff)
  }
  SaveObj(RPM, path = MakePath(CFG$paths$results, "RPM"))
  COUNTS$RPM <- RPM
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(chk, roi, lbl, RPM))
```

```{r bigwigs_rpm, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$bigwigs, "RPM"))
Mia.files$bw_rpm <- fmap(
  MakePath, CFG$paths$bigwigs, "RPM", Mia.files$name, ext = ".bw"
)
# =============================================================================.
# Generate normalized bigwigs 
# -----------------------------------------------------------------------------.
if(HostName() == "bl_imac") { # bigwigs are available on my work iMac only
  if(with(CFG$build, update | BigWigs.RPM)) {
    for(lbl in Mia.files$name) {
      message(clock(), " ", lbl , " | loading mapped reads...")
      aln <- readRDS(Mia.files[lbl]$rdata)
      message(clock(), " ", lbl , " | computing coverage...")
      cvg <- coverage(as(aln, "GRanges"))
      cvg <- cvg * YIELDS[lbl, ]$rpm_coeff
      message(clock(), " ", lbl , " | saving as bigwig...")
      export.bw(cvg, Mia.files[lbl]$bw_rpm)
    }
  }
  if(! all(file.exists(Mia.files$bw_rpm))) stop("missing RPM bigwig files")
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(lbl, aln, cvg))
gc() # Garbage collector
```

```{r normalization_brd, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$results, "BRD"))
mkdir(MakePath(CFG$paths$images,  "BRD"))
# =============================================================================.
# Compute scaling factors (Tighrope::BRD method)
# -----------------------------------------------------------------------------.
chk <- LoadObj(BRD, path = MakePath(CFG$paths$results, "BRD"), pos = COUNTS)
if(with(CFG$build, update | Normalize.BRD | ! chk)) {
  for(grp in names(CFG$args$BRD)) {
    # -------------------------------------------------------------------------.
    roi  <- CFG$args$BRD[[grp]]$roi
    chip <- CFG$args$BRD[[grp]]$chip
    ctrl <- CFG$args$BRD[[grp]]$ctrl
    # -------------------------------------------------------------------------.
    roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
    cnt <- COUNTS$RAW[[roi]][roi.chk, c(chip, ctrl)]
    nrm <- with(
      CFG$args$BRD[[grp]],
      Tightrope::BRD(cnt, controls = ctrl, smobs = T, ncl = ncl, bdt = bdt)
    )
    # -------------------------------------------------------------------------.
    mkdir(MakePath(CFG$paths$images,  "BRD", roi))
    png(
      MakePath(CFG$paths$images, "BRD", roi, grp, ext = ".png"),
      width = 9, height = 3.3, units = "in", res = 300
    )
    layout(matrix(1:3, 1, 3, byrow = T))
    par(pch = 20)
    PlotBRD(nrm)
    dev.off()
    # -------------------------------------------------------------------------.
    mkdir(MakePath(CFG$paths$results, "BRD", roi, grp))
    SaveObj(nrm, path = MakePath(CFG$paths$results, "BRD", roi, grp))
    # -------------------------------------------------------------------------.
    lbl <- nrm$parameters$experiments
    BRD <- COUNTS$RAW
    for(roi in names(BRD)) {
      BRD[[roi]] <- t(t(BRD[[roi]][, lbl]) * 2^nrm$normfactors[lbl])
    }
    SaveObj(BRD, path = MakePath(CFG$paths$results, "BRD", roi, grp))
  }
}
# -----------------------------------------------------------------------------.
NORMALIZATIONS <- new.env(parent = globalenv(), size = NA)
for(grp in names(CFG$args$BRD)) {
  roi  <- CFG$args$BRD[[grp]]$roi
  chk <- LoadObj(
    nrm, path = MakePath(CFG$paths$results, "BRD", roi, grp), overload = T
  ) 
  NORMALIZATIONS[[grp]] <- nrm
  NORMALIZATIONS[[grp]]$genomic_intervals <- roi
}
# -----------------------------------------------------------------------------.
grp <- "Combined"
nrm <- NORMALIZATIONS[[grp]]
roi <- CFG$args$BRD[[grp]]$roi
x <- MakePath(CFG$paths$results, "BRD", "BRD", ext = ".rdata")
d <- MakePath(CFG$paths$results, "BRD", roi, grp, "BRD", ext = ".rdata")
mklnk(x, dest = normalizePath(d))
chk <- LoadObj(
  BRD, path = MakePath(CFG$paths$results, "BRD"), pos = COUNTS, overload = T
)
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(
  rm(chk, roi, grp, chip, ctrl, roi.chk, cnt, nrm, lbl, BRD, x, d)
)
```

```{r bigwigs_brd, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$bigwigs, "BRD"))
for(grp in names(CFG$args$BRD)) {
  roi <- CFG$args$BRD[[grp]]$roi
  lst <- NORMALIZATIONS[[grp]]$parameters$experiments
  mkdir(MakePath(CFG$paths$bigwigs, "BRD", roi, grp))
  bwg <- fmap(MakePath, CFG$paths$bigwigs, "BRD", roi, grp, lst, ext = ".bw")
  names(bwg) <- lst
  NORMALIZATIONS[[grp]]$bigwigs <- bwg
}
# =============================================================================.
# Generate normalized bigwigs 
# -----------------------------------------------------------------------------.
if(HostName() == "bl_imac") { # bigwigs are available on my work iMac only
  if(with(CFG$build, update | BigWigs.BRD)) {
    for(grp in names(CFG$args$BRD)) {
      for(lbl in NORMALIZATIONS[[grp]]$parameters$experiments) {
        message(clock(), " ", grp , " | ", lbl , " | loading mapped reads...")
        aln <- readRDS(Mia.files[lbl]$rdata)
        message(clock(), " ", grp , " | ", lbl , " | computing coverage...")
        cvg <- coverage(as(aln, "GRanges"))
        cvg <- cvg * 2^NORMALIZATIONS[[grp]]$normfactors[lbl]
        message(clock(), " ", grp , " | ", lbl , " | saving as bigwig...")
        export.bw(cvg, NORMALIZATIONS[[grp]]$bigwigs[lbl])
      }
    }
  }
  for(grp in names(CFG$args$BRD)) {
    if(! all(file.exists(NORMALIZATIONS[[grp]]$bigwigs))) {
      stop("missing BRD bigwig files")
    }
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(grp, roi, lst, bwg, lbl, aln, cvg))
gc() # Garbage collector
```


```{r distributions_raw, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$images, "RAW", "distributions"))
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | Distributions.RAW)) {
  for(roi in CFG$plots$ROIs) {
    message(clock(), " RAW | ", roi , " | plot distributions...")
    
    roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
    lst <- CFG$plots$lst.distributions

    cnt <- log2(COUNTS$RAW[[roi]][roi.chk, CFG$plots$lst.distributions])
    
    PlotCountDistributionsNoLabels(
      cnt, MakePath("RAW", "distributions", roi), ylim = c(0, 15),
      ylab = "log2(counts)", main = paste(roi, "\nraw counts")
    )
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, roi.chk, lst, cnt))
```

```{r distributions_rpm, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$images, "RPM", "distributions"))
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | Distributions.RPM)) {
  for(roi in CFG$plots$ROIs) {
    message(clock(), " RPM | ", roi , " | plot distributions...")
    
    roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
    lst <- CFG$plots$lst.distributions

    cnt <- log2(COUNTS$RPM[[roi]][roi.chk, lst])
    
    PlotCountDistributionsNoLabels(
      cnt, MakePath("RPM", "distributions", roi), ylim = c(0, 15),
      ylab = "log2(counts)", main = paste(roi, "\nRPM counts")
    )
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, roi.chk, lst, cnt))
```

```{r enrichments_rpm, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$images, "RPM", "enrichments"))
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | Enrichments.RPM)) {
  for(roi in CFG$plots$ROIs) {
    message(clock(), " RPM | ", roi , " | plot enrichment distributions...")
    
    roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
    lst <- CFG$plots$lst.distributions
    
    cnt <- log2(COUNTS$RAW[[roi]][roi.chk, lst])
    cnt <- cnt[FiniteValues(cnt), ]
    
    lst <- Mia.meta[lst][antibody == "Input"]$sample_id
    cnt <- cnt - rowMeans(cnt[, lst])
    
    PlotCountDistributions(
      cnt, MakePath("RPM", "enrichments", roi), ylim = c(-5, 5),
      ylab = "log2ratio", main = paste(roi, "\nRPM enrichments")
    )
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, roi.chk, lst, cnt))
```

```{r distributions_brd, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$images, "BRD", "distributions"))
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | Distributions.BRD)) {
  for(roi in CFG$plots$ROIs) {
    message(clock(), " BRD | ", roi , " | plot distributions...")
    
    roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
    lst <- NORMALIZATIONS$Combined$parameters$experiments

    cnt <- log2(COUNTS$BRD[[roi]][roi.chk, lst])
    
    PlotCountDistributionsNoLabels(
      cnt, MakePath("BRD", "distributions", roi), ylim = c(0, 15),
      ylab = "log2(counts)", main = paste(roi, "\nBRD counts")
    )
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, roi.chk, lst, cnt))
```

```{r enrichments_brd, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$images, "BRD", "enrichments"))
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | Enrichments.BRD)) {
  for(roi in CFG$plots$ROIs) {
    message(clock(), " BRD | ", roi , " | plot enrichment distributions...")
    
    roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
    lst <- NORMALIZATIONS$Combined$parameters$experiments

    cnt <- log2(COUNTS$BRD[[roi]][roi.chk, lst])
    cnt <- cnt[FiniteValues(cnt), ]
    
    lst <- Mia.meta[lst][antibody == "Input"]$sample_id
    cnt <- cnt - rowMeans(cnt[, lst])
    
    PlotCountDistributionsNoLabels(
      cnt, MakePath("BRD", "enrichments", roi), ylim = c(-4, 6),
      ylab = "log2ratio", main = paste(roi, "\nBRD enrichments")
    )
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, roi.chk, lst, cnt))
```

```{r correlation_matrix, include=FALSE, out.width="30%"}
# =============================================================================.
# Compute global correlations
# -----------------------------------------------------------------------------.
chk <- LoadObj(GCM, path = CFG$paths$results)
if(with(CFG$build, update | GlobalCorrelations | ! chk)) {
  roi <- CFG$args$correlation.roi
  roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
  cnt <- COUNTS$RAW[[roi]]
  cnt <- log2(DitherCounts(cnt[roi.chk, ]))
  cnt <- cnt[FiniteValues(cnt), ]
  GCM <- CorrelationMatrix(cnt)
  SaveObj(GCM, path = CFG$paths$results)
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(chk, roi, roi.chk, cnt))
```

```{r reproducibility_raw, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$images, "RAW", "reproducibility"))
# =============================================================================.
# Reproducibility scatter plots
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | Reproducibility.RAW)) {
  roi <- CFG$args$correlation.roi
  roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
  mkdir(MakePath(CFG$paths$images, "RAW", "reproducibility", roi))
  for(abd in unique(Mia.meta$antibody)) {
    for(bix in unique(Mia.meta$treatment)) {
      lbl <- paste(abd, bix, sep = "_")
      message(clock(), " ", lbl , " | plot reproducibility...")
      r1 <- paste(abd, bix, "35", sep = "_")
      r2 <- paste(abd, bix, "25", sep = "_")
      xylim <- c(-2, 17)
      cnt <- COUNTS$RAW[[roi]][roi.chk, c(r1, r2)]
      cnt <- DitherCounts(cnt)
      flp <- MakePath("RAW", "reproducibility", roi, lbl)
      PlotReproducibility(log2(cnt), GCM, r1, r2, path = flp, xylim)
    }
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, roi.chk, abd, bix, lbl, r1, r2, xylim, cnt, flp))
```

```{r chip_input_rpm, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$images, "RPM", "ChIP_x_Input"))
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | ChIP_x_Input.RPM)) {
  roi <- CFG$args$correlation.roi
  roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
  mkdir(MakePath(CFG$paths$images, "RPM", "ChIP_x_Input", roi))
  for(abd in unique(Mia.meta[antibody != "Input"]$antibody)) {
    for(bix in unique(Mia.meta$treatment)) {
      for(did in unique(Mia.meta$donor_id)) {
        lbl <- paste(abd, bix, did, sep = "_")
        message(clock(), " ", lbl , " | plot ChIP/Input...")
        r1 <- paste("Input", bix, did, sep = "_")
        r2 <- paste(abd, bix, did, sep = "_")
        xylim <- c(-2, 17)
        cnt <- COUNTS$RAW[[roi]][roi.chk, c(r1, r2)]
        cnt <- DitherCounts(cnt)
        cnt <- t(t(cnt) * YIELDS[colnames(cnt), ]$rpm_coeff)
        flp <- MakePath("RPM", "ChIP_x_Input", roi, lbl)
        PlotReproducibility(log2(cnt), GCM, r1, r2, path = flp, xylim, r = F)
      }
    }
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(
  rm(roi, roi.chk, abd, bix, did, lbl, r1, r2, xylim, cnt, flp)
)
```

```{r chip_input_brd, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$images, "BRD", "ChIP_x_Input"))
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | ChIP_x_Input.BRD)) {
  lst <- NORMALIZATIONS$Combined$parameters$experiments
  roi <- CFG$args$correlation.roi
  roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
  mkdir(MakePath(CFG$paths$images, "BRD", "ChIP_x_Input", roi))
  for(abd in unique(Mia.meta[lst][antibody != "Input"]$antibody)) {
    for(bix in unique(Mia.meta[lst]$treatment)) {
      for(did in unique(Mia.meta[lst]$donor_id)) {
        lbl <- paste(abd, bix, did, sep = "_")
        message(clock(), " ", lbl , " | plot ChIP/Input...")
        r1 <- paste("Input", bix, did, sep = "_")
        r2 <- paste(abd, bix, did, sep = "_")
        xylim <- c(-2, 17)
        cnt <- COUNTS$RAW[[roi]][roi.chk, c(r1, r2)]
        cnt <- DitherCounts(cnt)
        cnt <- t(t(cnt) * 2^NORMALIZATIONS$Combined$normfactors[colnames(cnt)])
        flp <- MakePath("BRD", "ChIP_x_Input", roi, lbl)
        PlotReproducibility(log2(cnt), GCM, r1, r2, path = flp, xylim, r = F)
      }
    }
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(
  rm(lst, roi, roi.chk, abd, bix, did, lbl, r1, r2, xylim, cnt, flp)
)
```

```{r bix_effect_rpm, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$images, "RPM", "BIX_effect"))
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | BIX_effect.RPM)) {
  for(roi in CFG$plots$ROIs) {
    roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
    mkdir(MakePath(CFG$paths$images, "RPM", "BIX_effect", roi))
    for(abd in unique(Mia.meta[antibody != "Input"]$antibody)) {
      for(did in unique(Mia.meta$donor_id)) {
        lbl <- paste(abd, did, sep = "_")
        message(clock(), " ", lbl , " | plot ChIP/Input...")
        r1 <- paste(abd, "untreated", did, sep = "_")
        r2 <- paste(abd, "BIX", did, sep = "_")
        xylim <- c(-2, 15)
        cnt <- COUNTS$RAW[[roi]][roi.chk, c(r1, r2)]
        cnt <- DitherCounts(cnt)
        cnt <- t(t(cnt) * YIELDS[colnames(cnt), ]$rpm_coeff)
        flp <- MakePath("RPM", "BIX_effect", roi, lbl)
        PlotReproducibility(
          log2(cnt), GCM, r1, r2, path = flp, xylim, r = F, main = roi
        )
      }
    }
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, roi.chk, abd, did, lbl, r1, r2, xylim, cnt, flp))
```

```{r bix_effect_brd, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$images, "BRD", "BIX_effect"))
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | BIX_effect.BRD)) {
  lst <- NORMALIZATIONS$Combined$parameters$experiments
  for(roi in CFG$plots$ROIs) {
    roi.chk <- countOverlaps(EGA91[[roi]], blacklist) == 0
    mkdir(MakePath(CFG$paths$images, "BRD", "BIX_effect", roi))
    for(abd in unique(Mia.meta[lst][antibody != "Input"]$antibody)) {
      for(did in unique(Mia.meta[lst]$donor_id)) {
        lbl <- paste(abd, did, sep = "_")
        message(clock(), " ", lbl , " | plot ChIP/Input...")
        r1 <- paste(abd, "untreated", did, sep = "_")
        r2 <- paste(abd, "BIX", did, sep = "_")
        xylim <- c(-2, 17)
        cnt <- COUNTS$RAW[[roi]][roi.chk, c(r1, r2)]
        cnt <- DitherCounts(cnt)
        cnt <- t(t(cnt) * 2^NORMALIZATIONS$Combined$normfactors[colnames(cnt)])
        flp <- MakePath("BRD", "BIX_effect", roi, lbl)
        PlotReproducibility(
          log2(cnt), GCM, r1, r2, path = flp, xylim, r = F, main = roi
        )
      }
    }
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(lst, roi, roi.chk, abd, did, lbl, r1, r2, xylim, cnt, flp))
```

```{r seqplots_rpm, include=FALSE}
# =============================================================================.
# Create paths
# -----------------------------------------------------------------------------.
mkdir(MakePath(CFG$paths$results, "RPM", "SeqPlots"))
# -----------------------------------------------------------------------------.
if(with(CFG$build, update | SeqPlots.RPM)) {
  for(did in unique(Mia.meta$donor_id)) {
    
    flp <- MakePath(CFG$paths$results, "RPM", "SeqPlots", did)
    mkdir(flp)
    
    lst <- Mia.meta[CFG$plots$lst.distributions][donor_id == did]$sample_id
    bwg <- Mia.files[lst]$bw_rpm
    
    GNU <- getPlotSetArray(
      bwg, features = MakePath(CFG$paths$data, "EGA91_GNU.bed"),
      refgenome = CFG$organism$UCSC$genome, ignore_strand = F, 
      bin = 100, xmin = 4000, xmax = 4000, xanchored = 8000, type = "af",
      add_heatmap = T
    )
    SaveObj(GNU, flp)
    
    INTERGENIC <- getPlotSetArray(
      bwg, features = MakePath(CFG$paths$data, "EGA91_INTERGENIC.bed"),
      refgenome = CFG$organism$UCSC$genome, ignore_strand = F, 
      bin = 100, xmin = 4000, xmax = 4000, xanchored = 8000, type = "af",
      add_heatmap = T
    )
    SaveObj(INTERGENIC, flp)
    
    TSS <- getPlotSetArray(
      bwg, features = MakePath(CFG$paths$data, "EGA91_TSS.bed"),
      refgenome = CFG$organism$UCSC$genome, ignore_strand = F, 
      bin = 100, xmin = 3000, xmax = 3000, type = "mf",
      add_heatmap = T
    )
    SaveObj(TSS, flp)
    
    TTS <- getPlotSetArray(
      bwg, features = MakePath(CFG$paths$data, "EGA91_TTS.bed"),
      refgenome = CFG$organism$UCSC$genome, ignore_strand = F, 
      bin = 100, xmin = 3000, xmax = 3000, type = "mf",
      add_heatmap = T
    )
    SaveObj(TTS, flp)
  }
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(did, flp, lst, bwg, GNU, INTERGENIC, TSS, TTS))
```

```{r build_biblio, include=FALSE}
# =============================================================================.
# Bibliographic references
# -----------------------------------------------------------------------------.
pmids <- c(
  # 27941817, # Lusic & Siliciano 2017
  # 25731161, # Marini et al 2015
  25525795, # Demeulemeester et al 2014
  27154821  # Zhu et al 2016
)
if(with(CFG$build, update | Biblio | ! LoadObj(BIBLIO, CFG$paths$biblio))) {
  fpath <- MakePath(CFG$paths$biblio, "Bibliography.bib")
  BIBLIO <- PubmedBiblioBibtex(pmids, fpath) 
  SaveObj(BIBLIO, CFG$paths$biblio)
}
```

```{r build_studies, include=FALSE}
if(with(CFG$build, update | Biblio | ! LoadObj(STUDIES, CFG$paths$biblio))) {
  bib <- PubmedBiblio(pmids)
  STUDIES <- data.table(
    name      = "",
    author    = bib$lastname,
    year      = unlist(lapply(BIBLIO, function(x) x$year)),
    journal   = bib$jabbrv,
    pubmed    = pmids,
    accession = "",
    reference = unlist(lapply(BIBLIO, names)),
    organism  = "",
    doi       = unlist(lapply(BIBLIO, function(x) x$doi)),
    citations = PubmedCitationNumber(pmids)
  )
  SaveObj(STUDIES, CFG$paths$biblio)
}
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(pmids, fpath, bib))
```

\newpage

# Dataset

```{r show_chipseq_mia, echo=FALSE, out.width="50%"}
# =============================================================================.
# Mia's ChIP-seq October 2017
# -----------------------------------------------------------------------------.
lst <- CFG$plots$lst.distributions
tbl <- Mia.meta[lst, c(3:7, 9)]
kable(tbl, caption = "Mia's ChIP-seq October 2017")
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(lst, tbl))
```

# Sequencing

```{r show_yields_legend, echo=FALSE, fig.height=2, out.width="30%", fig.align='center'}
clr <- grey(1:3/3)
empty.plot(axes = F)
par(mar = c(1, 7, 1, 2), cex = 1)
legend(
  "center", horiz = T, bty = "n", box.cex = c(1, 8),
  legend = c("usable", "filtered", "not mapped"), fill = clr
)
```

```{r show_yields, echo=FALSE, fig.height=7, out.width="30%"}
lst <- CFG$plots$lst.distributions
par(mar = c(12, 7, 4, 2), cex = 1.4)

# Percentages of sequencing reads after mapping and filtering
tbl <- YIELDS[lst, c("rdata", "mapped", "fastq")]
tbl <- cbind(0, 100 * tbl / tbl$fastq)
tbl <- apply(tbl, 1, diff)
barplot(tbl, las = 2, ylim = c(0, 100), col = clr, ylab = "% reads")

# Number of usable reads
tbl <- as.matrix(YIELDS)[lst, "rdata", drop = F]
barplot(t(tbl), las = 2, main = "usable reads")

# Fraction of the genome covered by usable reads
tbl <- as.matrix(YIELDS)[lst, c("covered", "seqlength")]
tbl <- 100 * tbl[, 1, drop = F] / tbl[, 2, drop = F]
barplot(
  t(tbl), las = 2, ylim = c(0, 100), ylab = "% bp",
  main = paste0("genomic coverage (", CFG$organism$UCSC$genome, ")")
)
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(clr, lst, tbl))
```

```{r show_dna_fragments, echo=FALSE, fig.height=5, out.width="50%", fig.align='center'}
lst <- CFG$plots$lst.distributions
clr <- c(rep(grey(0.3), 6), rep(rgb(1, 0.5, 0), 6))
clr[c(7, 9:10)] <- "red"
tbl <- 100 * DNAFRAGMENTS[lst, ] / YIELDS[lst, "rdata"]

x <- CFG$args$dna.fragments$breaks
n <- length(x) - 1

par(cex = 1.1)
empty.plot(
  xlim = 1.1 * range(x), ylim = range(tbl),
  xlab = "bp", ylab = "% reads", main = "DNA fragment sizes"
)

for(i in 1:nrow(tbl)) {
  points(x[1:n], tbl[i, ], type = "l", col = clr[i], lwd = 1.5)  
}
legend("topright", lst, fill = clr, bty = "n")
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(lst, clr, tbl, x, n, i))
```

\newpage

# ChIP-seq profiles

## Genome-wide correlations

The heatmap below represent pairwise Pearson correlation coefficients between
ChIP-seq profiles based on raw read counts over whole genome tiling bins.

```{r show_correlation_legend, echo=FALSE, fig.height=4, out.width="25%", fig.align='center'}
clr.prm <- defineColors(
  thresholds = c(-1.0, -0.5, 0.0, 0.5, 1.0), centered = T,
  colors = c(
    rgb(0.0, 0.0, 0.8),
    rgb(0.2, 0.8, 1.0),
    rgb(0.3, 0.3, 0.3),
    rgb(1.0, 0.0, 0.0),
    rgb(1.0, 1.0, 0.0)
  )
)
par(cex = 1.5)
empty.plot(axes = F)
colorLegend(
  "b", horiz = T, size = c(95, 15), margin = rep(1, 4),
  parameters = clr.prm, resolution = 101,
  ticks = seq(-1, 1, length.out = 5), tick.pos = -1, tick.size = 10
)
legend("top", "Pearson correlation", bty = "n")
```

```{r show_correlation, echo=FALSE, out.width="80%", fig.align="center"}
PlotCorrelationHeatmap(
  GCM, clr.prm, margins = c(12, 12), cexRow = 0.8, cexCol = 0.8
)
```

## Correlations per donor

```{r show_correlation_by_donor, echo=FALSE, out.width="40%"}
chk <- grepl("_25", colnames(GCM))
PlotCorrelationHeatmap(
  GCM[chk, chk], clr.prm, margins = c(12, 12), cexRow = 1.1, cexCol = 1.1
)
chk <- grepl("_35", colnames(GCM))
PlotCorrelationHeatmap(
  GCM[chk, chk], clr.prm, margins = c(12, 12), cexRow = 1.1, cexCol = 1.1
)
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(clr.prm, chk))
```

\newpage

## Reproducibility between donors

The scatterplots below represent pairwise comparisons between matching ChIP-seq
profiles from donor 35 (horizontal axes) and donor 25 (vertical axes) using
raw read counts over whole genome tiling bins. Densities of read count
values are represented using a color gradient from dark grey (low density)
to cyan (high density). Pearson correlation coefficients are indicated in the
top left corner of each panel.

```{r show_reproducibility_legend, echo=FALSE, fig.height=4, out.width="25%", fig.align='center'}
clr.prm <- AutoColorParameters("Bc")
clr.prm$range <- c(-1, 1)
clr.prm$below <- grey(1)
clr.prm$extra <- c(0.02, 1)
par(cex = 1.5)
empty.plot(axes = F)
colorLegend(
  "b", horiz = T, size = c(95, 15), margin = rep(1, 4),
  parameters = clr.prm, resolution = 101,
  ticks = seq(0, 1, length.out = 5), tick.pos = -1, tick.size = 10, 
)
legend("top", "density score", bty = "n")
```

```{r show_reproducibility_part1, echo=FALSE, out.width="30%"}
roi <- CFG$args$correlation.roi
img <- MakePath(CFG$paths$images, "RAW", "reproducibility", roi)
lbl <- "H3K36me3_untreated"
include_graphics(MakePath(img, lbl, ext = ".png"))
lbl <- "LEDGF_untreated"
include_graphics(MakePath(img, lbl, ext = ".png"))
lbl <- "Input_untreated"
include_graphics(MakePath(img, lbl, ext = ".png"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, img, lbl))
```

```{r show_reproducibility_part2, echo=FALSE, out.width="30%"}
roi <- CFG$args$correlation.roi
img <- MakePath(CFG$paths$images, "RAW", "reproducibility", roi)
lbl <- "H3K36me3_BIX"
include_graphics(MakePath(img, lbl, ext = ".png"))
lbl <- "LEDGF_BIX"
include_graphics(MakePath(img, lbl, ext = ".png"))
lbl <- "Input_BIX"
include_graphics(MakePath(img, lbl, ext = ".png"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, img, lbl))
```

\newpage

## Specificity of enrichments

The scatterplots below represent pairwise comparisons between matching Input
(horizontal axes) and ChIP (vertical axes) profiles using normalized
read counts (see Material & methods) over whole genome tiling bins.

```{r echo=FALSE, ref.label='show_reproducibility_legend', fig.height=4, out.width="25%", fig.align='center'}
```

```{r show_chip_input_rpm_part1, echo=FALSE, out.width="27%"}
roi <- CFG$args$correlation.roi
img <- MakePath(CFG$paths$images, "RPM", "ChIP_x_Input", roi)
lbl <- "H3K36me3_untreated_35"
include_graphics(MakePath(img, lbl, ext = ".png"))
lbl <- "H3K36me3_untreated_25"
include_graphics(MakePath(img, lbl, ext = ".png"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, img, lbl))
```

```{r show_chip_input_rpm_part2, echo=FALSE, out.width="27%"}
roi <- CFG$args$correlation.roi
img <- MakePath(CFG$paths$images, "RPM", "ChIP_x_Input", roi)
lbl <- "H3K36me3_BIX_35"
include_graphics(MakePath(img, lbl, ext = ".png"))
lbl <- "H3K36me3_BIX_25"
include_graphics(MakePath(img, lbl, ext = ".png"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, img, lbl))
```

```{r show_chip_input_rpm_part3, echo=FALSE, out.width="27%"}
roi <- CFG$args$correlation.roi
img <- MakePath(CFG$paths$images, "RPM", "ChIP_x_Input", roi)
lbl <- "LEDGF_untreated_35"
include_graphics(MakePath(img, lbl, ext = ".png"))
lbl <- "LEDGF_untreated_25"
include_graphics(MakePath(img, lbl, ext = ".png"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, img, lbl))
```

```{r show_chip_input_rpm_part4, echo=FALSE, out.width="27%"}
roi <- CFG$args$correlation.roi
img <- MakePath(CFG$paths$images, "RPM", "ChIP_x_Input", roi)
lbl <- "LEDGF_BIX_35"
include_graphics(MakePath(img, lbl, ext = ".png"))
lbl <- "LEDGF_BIX_25"
include_graphics(MakePath(img, lbl, ext = ".png"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, img, lbl))
```

\newpage

## Range of enrichments

ChIP-seq enrichments are expressed as log2 ratio of ChIP over Input read counts
after normalization (RPM, see Material & methods).
The distribution of these enrichment values are shown for 3 sets of genomic
intervals with densities represented by a color gradient from grey
(low density) to red (medium density) and yellow (high density).
Genomic intervals are labeled as follows:

  - WGT: Whole Genome Tiling with bins of 4kb size and 1kb spacing
  - TSS: 4kb windows centered on Transcription Start Sites
  - TTS: 4kb windows centered on Transcription Termination Sites

```{r show_enrichments_legend, echo=FALSE, fig.height=4, out.width="25%", fig.align='center'}
clr.prm <- AutoColorParameters("ry")
clr.prm$range <- c(-1, 1)
clr.prm$below <- grey(1)
clr.prm$extra <- c(0.02, 1)
par(cex = 1.5)
empty.plot(axes = F)
colorLegend(
  "b", horiz = T, size = c(95, 15), margin = rep(1, 4),
  parameters = clr.prm, resolution = 101,
  ticks = seq(0, 1, length.out = 5), tick.pos = -1, tick.size = 10, 
)
legend("top", "density score", bty = "n")
```

```{r show_enrichments_rpm, echo=FALSE, out.width="30%"}
img <- MakePath(CFG$paths$images, "RPM", "enrichments")
roi <- "WGT"
include_graphics(MakePath(img, roi, ext = ".png"))
roi <- "TSS"
include_graphics(MakePath(img, roi, ext = ".png"))
roi <- "TTS"
include_graphics(MakePath(img, roi, ext = ".png"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(img, roi))
```

\newpage

# Global effect of BIX treatment

## Donor 35

Genomic intervals are labeled as follows:

  - WGT: Whole Genome Tiling with bins of 4kb size and 1kb spacing
  - TSS: 4kb windows centered on Transcription Start Sites
  - TTS: 4kb windows centered on Transcription Termination Sites

```{r show_seqplots_legend, echo=FALSE, fig.height=2, out.width="100%", fig.align='center'}
clr <- c(
  H3K36me3_untreated = rgb(0.0, 0.0, 0.5, 0.7),
  H3K36me3_BIX       = rgb(0.0, 0.5, 0.0, 0.7),
  LEDGF_untreated    = rgb(0.5, 0.0, 0.0, 0.7),
  LEDGF_BIX          = rgb(0.5, 0.0, 0.5, 0.7),
  Input_untreated    = rgb(0.5, 0.5, 0.5, 0.7),
  Input_BIX          = rgb(1.0, 0.5, 0.0, 0.7)
)
par(mar = c(1, 1, 1, 1))
empty.plot(axes = F)
legend("center", names(clr), fill = clr, horiz = T, bty = "n", cex = 0.5)
```

```{r show_seqplots_rpm_part1, echo=FALSE, message=FALSE, out.width="32%"}
flp <- MakePath(CFG$paths$results,"RPM", "SeqPlots")
did <- "35"
chk <- LoadObj(GNU, MakePath(flp, did), overload = T)
plotAverage(GNU, ylim = c(2.2, 5.5), main = "genes", ylab = "counts", legend = F)
chk <- LoadObj(TSS, MakePath(flp, did), overload = T)
plotAverage(TSS, ylim = c(2.0, 8.5), main = "TSS", ylab = "counts", legend = F)
chk <- LoadObj(TTS, MakePath(flp, did), overload = T)
plotAverage(TTS, ylim = c(2.0, 8.5), main = "TTS", ylab = "counts", legend = F)
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(flp, did, chk, GNU, TSS, TTS))
```

```{r ref.label='show_reproducibility_legend', echo=FALSE, fig.height=4, out.width="25%", fig.align='center'}
```

```{r show_bix_effect_rpm_part1, echo=FALSE, out.width="30%"}
lbl <- "H3K36me3_35"
img <- MakePath(CFG$paths$images, "RPM", "BIX_effect")
roi <- "WGT"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
roi <- "TSS"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
roi <- "TTS"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(lbl, img, roi))
```

```{r show_bix_effect_rpm_part2, echo=FALSE, out.width="30%"}
lbl <- "LEDGF_35"
img <- MakePath(CFG$paths$images, "RPM", "BIX_effect")
roi <- "WGT"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
roi <- "TSS"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
roi <- "TTS"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, img, lbl))
```

\newpage

## Donor 25

Genomic intervals are labeled as follows:

  - WGT: Whole Genome Tiling with bins of 4kb size and 1kb spacing
  - TSS: 4kb windows centered on Transcription Start Sites
  - TTS: 4kb windows centered on Transcription Termination Sites

```{r ref.label='show_seqplots_legend', echo=FALSE, fig.height=2, out.width="100%", fig.align='center'}
```

```{r show_seqplots_rpm_part2, echo=FALSE, message=FALSE, out.width="32%"}
flp <- MakePath(CFG$paths$results,"RPM", "SeqPlots")
did <- "25"
chk <- LoadObj(GNU, MakePath(flp, did), overload = T)
plotAverage(GNU, ylim = c(2.2, 5.5), main = "genes", ylab = "counts", legend = F)
chk <- LoadObj(TSS, MakePath(flp, did), overload = T)
plotAverage(TSS, ylim = c(2.0, 8.5), main = "TSS", ylab = "counts", legend = F)
chk <- LoadObj(TTS, MakePath(flp, did), overload = T)
plotAverage(TTS, ylim = c(2.0, 8.5), main = "TTS", ylab = "counts", legend = F)
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(flp, did, chk, GNU, TSS, TTS))
```

```{r echo=FALSE, ref.label='show_reproducibility_legend', fig.height=4, out.width="25%", fig.align='center'}
```

```{r show_bix_effect_rpm_part3, echo=FALSE, out.width="30%"}
lbl <- "H3K36me3_25"
img <- MakePath(CFG$paths$images, "RPM", "BIX_effect")
roi <- "WGT"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
roi <- "TSS"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
roi <- "TTS"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(lbl, img, roi))
```

```{r show_bix_effect_rpm_part4, echo=FALSE, out.width="30%"}
lbl <- "LEDGF_25"
img <- MakePath(CFG$paths$images, "RPM", "BIX_effect")
roi <- "WGT"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
roi <- "TSS"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
roi <- "TTS"
include_graphics(MakePath(img, roi, lbl, ext = ".png"))
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(roi, img, lbl))
```

\newpage

# Control genes

The boxplots below show normalized H3K36me3 counts from donor 35 at TSS (left)
and TTS (right) of genes previously tested by ChIP-QPCR.

```{r chip_qpcr_rpm, echo=FALSE, out.width="50%"}
qpcr_boxplot <- function(gene_names, sample_names, cnt, grg, ylab, main) {
  
  idx <- which(grg$gene_name %in% gene_names)
  cnt <- cnt[idx, sample_names]
  nxp <- ncol(cnt)
  
  tbl <- data.frame(cnt)
  colnames(tbl) <- Mia.meta[colnames(tbl)]$treatment
  tbl$gene <- factor(grg$gene_name[idx], levels = gene_names)
  # tbl <- tbl[order(as.numeric(tbl$gene)), ]
  
  tbl <- tbl_df(tbl)
  tbl <- gather(tbl, key = "treatment", value = "ChIP", 1:nxp, factor_key = T)
  
  bp <- ggplot(tbl, aes(x = gene, y = ChIP, fill = treatment))
  bp <- bp + geom_boxplot(alpha = 1.0, outlier.colour = NA)
  bp <- bp + scale_y_continuous(minor_breaks = waiver())
  bp <- bp + scale_x_discrete()
  bp <- bp + scale_fill_grey(start = 0.5, end = 0.9)
  bp <- bp + theme_classic()
  bp <- bp + labs(title = main, y = ylab)
  bp <- bp + theme(plot.title = element_text(hjust = 0.5))
  bp
}

lst <- c(
  "BACH2", "STAT5B", "MKL2", "RPTOR", "NPLOC4", "KDM2B", "PACS2", "ACTN1",
  "CNTN4"
)

bp <- qpcr_boxplot(
  lst, CFG$args$BRD$H3K36me3$chip, COUNTS$RPM$TSS, EGA91$TSS,
  ylab = "H3K36me3", main = "TSS"
)
print(bp)

bp <- qpcr_boxplot(
  lst, CFG$args$BRD$H3K36me3$chip, COUNTS$RPM$TTS, EGA91$TTS,
    ylab = "H3K36me3", main = "TTS"
)
print(bp)
```

## BACH2

```{r BACH2_rpm, echo=FALSE, out.width="100%"}
include_graphics(MakePath(CFG$paths$images, "tracks", "BACH2.png"))
```

## STAT5B

```{r STAT5B_rpm, echo=FALSE, out.width="100%"}
include_graphics(MakePath(CFG$paths$images, "tracks", "STAT5B.png"))
```

## MKL2

```{r MKL2_rpm, echo=FALSE, out.width="100%"}
include_graphics(MakePath(CFG$paths$images, "tracks", "MKL2.png"))
```

## RPTOR

```{r RPTOR_rpm, echo=FALSE, out.width="100%"}
include_graphics(MakePath(CFG$paths$images, "tracks", "RPTOR.png"))
```

## NPLOC4

```{r NPLOC4_rpm, echo=FALSE, out.width="100%"}
include_graphics(MakePath(CFG$paths$images, "tracks", "NPLOC4.png"))
```

## KDM2B

```{r KDM2B_rpm, echo=FALSE, out.width="100%"}
include_graphics(MakePath(CFG$paths$images, "tracks", "KDM2B.png"))
```

## PACS2

```{r PACS2_rpm, echo=FALSE, out.width="100%"}
include_graphics(MakePath(CFG$paths$images, "tracks", "PACS2.png"))
```

## ACTN1

```{r ACTN1_rpm, echo=FALSE, out.width="100%"}
include_graphics(MakePath(CFG$paths$images, "tracks", "ACTN1.png"))
```

## CNTN4

```{r CNTN4_rpm, echo=FALSE, out.width="100%"}
include_graphics(MakePath(CFG$paths$images, "tracks", "CNTN4.png"))
```

\newpage

# Material & methods

  + Human genes, TSS and TTS were retrieved from the
  ```{r link_txdb_source, ref.label='txdb_source', echo=FALSE, results='asis'}
  ```
    database.
    Gene biotypes and [HGNC](https://www.genenames.org) symbols were retrieved
    from the same archived version of Ensembl with Bioconductor package
    [biomaRt](http://bioconductor.org/packages/release/bioc/html/biomaRt.html)
  
  + Informations about problematic regions identified by the ENCODE consortium
    were retrieved from Anshul Kundaje's
    [webpage](https://sites.google.com/site/anshulkundaje/projects/blacklists)
    and
    [datasets](https://sites.google.com/site/anshulkundaje/projects/blacklists).
    Blacklisted regions were defined as the consensus list established by ENCODE
    for the GRCh37 (hg19) build of the Human genome. 
      
  + Human genome coordinate conversions from GRCh37 (hg19) to
    GRCh38 (hg38) builds were performed using the reimplementation
    of UCSC's liftOver tool provided in Bioconductor package
    [rtracklayer](https://bioconductor.org/packages/release/bioc/html/rtracklayer.html)
  
  + Paired-end ChIP-seq reads were preprocessed and mapped using Galaxy.
    Read trimming was performed with the Trim Galore tool (version 0.4.3) using
    default parameters except a  phred quality score threshold of 25
    and a minimum required sequence length of 50bp.
    
    Trimmed reads were mapped on the Human genome (hg38, canonical) with the
    BWA-MEM tool (version 0.7.15) using _Simple Illumina Mode_
    and values of 350bp, 100 and 700bp for the mean, standard deviation
    and maximum insert lengths respectively.
    
    All subsequent analyses of the ChIP-seq dataset were performed within the
    R environment based on successfully mapped and filtered reads,
    the post-mapping filters consisting in removing duplicated sequence
    and retaining proper read pairs only.
  
  + Normalizations were performed using the standard Reads Per Millions
    (RPM) of mapped reads method, which practically consists in rescaling read
    counts of each profile according to its sequencing depth.
  
  + Blacklisted regions were systematically excluded from analyses
    involving read counts or enrichment values.
  
```{r public_data, eval=FALSE, include=FALSE}
# LEDGF <- list()
# LEDGF$Demeulemeester <- read.delim(
#   "../../data/LEDGF/GSE61003_Demeulemeester_et_al_2014/processed_data/GSM1495450_P75-PriT-zinba-peaks.broad.bed.gz",
#   header = F, stringsAsFactors = F
# )
# colnames(LEDGF$Demeulemeester) <- c("chr", "start", "end", "score.x", "score.y")
# LEDGF$Demeulemeester$score.y <- as.numeric(gsub("\\+", "", LEDGF$Demeulemeester$score.y))
# LEDGF$Demeulemeester <- as(LEDGF$Demeulemeester, "GRanges")
# LEDGF$Demeulemeester <- CleanupGRanges(LEDGF$Demeulemeester, hg19.seqinfo, EGA91$organism$name)
# LEDGF$Demeulemeester <- unlist(liftOver(LEDGF$Demeulemeester, hg19ToHg38))
# LEDGF$Demeulemeester <- with(EGA91, CleanupGRanges(LEDGF$Demeulemeester, seqinfo, organism$name))


# LEDGF$Zhu <- import.bw(
#   "/Volumes/HD_10TB/DATA_UKH/2017_Mia_HIV_H3K9me2_BIX/GSE73528_Zhu_et_al_2016/GSM1897372_MV4-11_LEDGF.bw"
# )
# LEDGF$Zhu <- CleanupGRanges(LEDGF$Zhu, hg19.seqinfo, EGA91$organism$name)
# LEDGF$Zhu <- unlist(liftOver(LEDGF$Zhu, hg19ToHg38))
# LEDGF$Zhu <- with(EGA91, CleanupGRanges(LEDGF$Zhu, seqinfo, organism$name))
# LEDGF$Zhu <- with(LEDGF, Zhu[countOverlaps(Zhu, Zhu) == 1])
# export.bw(
#   LEDGF$Zhu,
#   "/Volumes/HD_10TB/DATA_UKH/2017_Mia_HIV_H3K9me2_BIX/GSE73528_Zhu_et_al_2016/GSM1897372_MV4-11_LEDGF_hg38.bw"
# )

```

```{r ranked_enrichments, eval=FALSE, include=FALSE}

# plotHeatmap(TTS, clstmethod = "none", sortrows = "increasing")

# y.u <- log2(COUNTS$NRM$H3K36me3$TTS[, "H3K36me3_untreated_35"])
# y.b <- log2(COUNTS$NRM$H3K36me3$TTS[, "H3K36me3_BIX_35"])
# y.i <- log2(COUNTS$NRM$H3K36me3$TTS[, c("Input_untreated_35", "Input_BIX_35")])
# 
# chk <- FiniteValues(cbind(y.u, y.b, y.i))
# y.u <- y.u[chk]
# y.b <- y.b[chk]
# y.i <- y.i[chk, ]
# y.i <- rowMeans(y.i)
# 
# y.u <- y.u - y.i
# y.b <- y.b - y.i
# 
# o <- order(y.u, decreasing = T)
# x <- 1:length(o)
# 
# plot(x, y.u[o], type = 'l', col = rgb(0.5, 0, 0, 0.5), lwd = 2)
# points(x, y.b[o], pch = 20, cex = 0.3, col = rgb(1.0, 0, 0, 0.1))
# points(x, y.u[o], type = 'l', col = rgb(0.5, 0, 0, 0.5), lwd = 2)
# points(x, y.i[o], pch = 20, cex = 0.3, col = rgb(0, 0, 0, 0.1))
```

```{r show_studies, eval=FALSE, include=FALSE}
# =============================================================================.
# Studies
# -----------------------------------------------------------------------------.
tbl <- STUDIES
tbl$journal   <- MarkdownLink(tbl$doi, txt = tbl$journal, lnk = link.doi)
tbl$pubmed    <- MarkdownLink(tbl$pubmed, lnk = link.pubmed)
tbl$accession <- MarkdownLink(tbl$accession, lnk = link.geo)
tbl$reference <- MarkdownCite(tbl$reference)
tbl$organism  <- NULL
tbl$doi       <- NULL
kable(tbl, caption = "Summary of available studies")
# Cleanup ---------------------------------------------------------------------.
suppressWarnings(rm(rex, tbl))
```

```{r show_config, eval=FALSE, include=FALSE, ref.label='global_config'}
```
